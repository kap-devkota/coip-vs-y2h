install.packages("pacman")
pacman::p_install(ggplot2)
knitr::opts_chunk$set(echo = TRUE)
m <- 100; m <- 10; n <- 12; k <- 10;
rhyper(nn, m, n, k)
nn <- 100; m <- 10; n <- 12; k <- 10;
rhyper(nn, m, n, k)
?rhyper
nn <- 100; m <- 10; n <- 12; k <- 10;
mean(rhyper(nn, m, n, k))
nn <- 50; m <- 10; n <- 12; k <- 10;
samples <- replicate(100, mean(rhyper(nn, m, n, k)))
samples
library(ggplot2)
typeof(samples)
nn <- 50; m <- 10; n <- 12; k <- 10;
samples <- replicate(100, mean(rhyper(nn, m, n, k)))
samples<-as.data.frame(x)
nn <- 50; m <- 10; n <- 12; k <- 10;
samples <- replicate(100, mean(rhyper(nn, m, n, k)))
samples<-as.data.frame(samples)
samples
ggplot2(samples, aes(x=samples))+
geom_histogram(color="black")
require(ggplot2)
library(ggplot2)
ggplot2(samples, aes(x=samples))+
geom_histogram(color="black")
ggplot(samples, aes(x=samples))+
geom_histogram(color="black")
ggplot(samples, aes(x=samples))+
geom_histogram(color="black",
fill="lightblue")
ggplot(samples, aes(x=samples))+
geom_histogram(color="black",
fill="lightblue",
bins = 10)
knitr::opts_chunk$set(echo = TRUE)
M <- matrix(c(3, 14), nrow=4, byrow=TRUE)
M
M <- matrix(c(3, 14), ncol=4, byrow=TRUE)
M
M <- matrix(1:12, ncol=4, byrow=TRUE)
M
M <- matrix(1:12, ncol=4, byrow=FALSE)
M
M <- matrix(rnorm(36), ncol=6, byrow=FALSE)
M
M <- matrix(1:36, ncol=6, byrow=FALSE)
M
M <- matrix(1:36, ncol=6, byrow=TRUE)
M
M * 2
M * M
M @ M
M %*% M
M <- matrix(1:36, ncol=6, byrow=TRUE)
M %*% M
M <- matrix(1, nrow=6, ncol=6, byrow=TRUE)
M %*% M
M <- matrix(1, nrow=6, ncol=6, byrow=TRUE)
M <- matrix(1:36, nrow=6, ncol=6, byrow=TRUE)
M
M <- matrix(rnorm(36), nrow = 6, byrow = TRUE)
M
M <- M * 2
M
M <- matrix(rnorm(36), nrow = 6, byrow = TRUE)
M
M <- M * 2
M
M <- M %*% M
M
M[:2,:2]
M[1:2,1:2]
M[c(1:2, 3),1:2]
M <- matrix(1, nrow=2, ncol=2, byrow=TRUE)
N <- matrix(2, nrow=2, ncol=3, byrow= TRUE)
[M;N]
O <- [M;N]
O <- cbind(M, N)
O
O
knitr::opts_chunk$set(echo = TRUE)
newcars <- rbind(cars, c(10, 20))
newcars <- cbind(cars, 0:49)
newcars
newcars <- cbind(cars, index=0:49)
newcars
newcars <- rbind(cars, c(10, 20))
newcars <- cbind(cars, index=0:49)
newcars
library(dplyr)
starwars
starwars
starwars %>%
filter(species == "Droid")
starwars %>%
filter(species == "Droid")
starwars %>%
filter(mass > 34)
apply(0, 2, sum)
apply(0, 2, sum)
apply(O, 2, sum)
transpose(O)
t(O)
movies <- c("IRONMAN", "BATMAN", "SPIDERMAN", "SUPERMAN")
lapply(movies, function(x) {ends_with("MAN", x)})
lapply(movies, function(x) {endsWith(x, "MAN")})
sapply(movies, function(x) {endsWith(x, "MAN")})
sapply(movies, function(x) {endsWith(x, "MAN")})[1]
install.packages("igraph")
install.packages("igraph")
library("dplyr")
# install.packages("igraph")
library("igraph")
dgc <- read.csv("../data/networks/coip_hc_full.tsv", sep = "\t", header = FALSE)
dgy <- read.csv("../data/networks/y2h_hc_full.tsv", sep = "\t", header = FALSE)
dgc[which(dgc$V1 > dgc$V2), c("V1", "V2")] <- dgc[which(dgc$V1 > dgc$V2), c("V2", "V1")]
dgy[which(dgy$V1 > dgy$V2), c("V1", "V2")] <- dgy[which(dgy$V1 > dgy$V2), c("V2", "V1")]
dG <- merge(Gc, Gy, by.x = c("V1", "V2"), by.y= c("V1", "V2"), all.x = FALSE, all.y = FALSE)
dG[c("V1", "V2")]
dG <- merge(dgc, dgy, by.x = c("V1", "V2"), by.y= c("V1", "V2"), all.x = FALSE, all.y = FALSE)
dG[c("V1", "V2")]
G <- graph_from_data_frame(dG[c("V1", "V2")], directed = FALSE) #, vertices = nodesG)
default_triangles <- length(triangles(G))
default_triangles
Gnodes <- V(G)$name
Gcnodes <- union(dgc$V1, dgc$V2)
Gynodes <- union(dgy$V1, dgy$V2)
Gcmissing <- setdiff(Gcnodes, Gnodes)
Gymissing <- setdiff(Gynodes, Gnodes)
# DEBUG
c(length(Gnodes), length(Gcnodes), length(Gynodes), length(Gcmissing), length(Gymissing))
# Simulation function. Sample pairs and edges
get_tcounts <- function(dftest, Gcommon, pairs, no_edges) {
nodestoadd <- union(pairs, V(Gcommon)$name)
edgetoadd  <- dftest[which(dftest$V1 %in% nodestoadd & dftest$V2 %in% nodestoadd), c("V1", "V2")]
edgetoadd <- edgetoadd[sample(nrow(edgetoadd), no_edges), ]
gtoadd <- graph_from_data_frame(edgetoadd, directed = FALSE)
g <- gtoadd %u% Gcommon
return(length(triangles(g)))
}
gc_tcounts <- c()
no_edges <- 400
K <- 20
for(i in 1:50) {
pairs <- sample(Gcmissing, K)
gc_tcounts <- c(gc_tcounts, get_tcounts(dgc, G, pairs, no_edges))
}
gc_tcounts
gy_tcounts <- c()
for(i in 1:50) {
pairs <- sample(Gymissing, K)
gy_tcounts <- c(gy_tcounts, get_tcounts(dgy, G, pairs, no_edges))
}
gy_tcounts
res <- t.test(gc_tcounts, gy_tcounts)
res
rbinom(10, 1, 0.1)
rbinom(10, 2, 0.1)
rbinom(10, 10, 0.1)
rbinom(10, 10, c(0.1, 0.5))
rbinom(1, 100, 0.1)
monte_carlo <- function(n_simulations, callback, ...) {
simulations <- 1:n_simulations
sapply(1:n_simulations, function(x){callback(...)})
}
# Given the test data-frame, common graph and sampled nodes, return the
# length of triangles
test1_callback <- function(dfGtest, Gcommon, missing_nodes, no_nodes, no_edges) {
sampled_nodes <- sample(missing_nodes, no_nodes)
nodestoadd <- union(sampled_nodes, V(Gcommon)$name)
edgetoadd  <- dftest[which(dftest$V1 %in% nodestoadd & dftest$V2 %in% nodestoadd), c("V1", "V2")]
edgetoadd <- edgetoadd[sample(nrow(edgetoadd), no_edges), ]
gtoadd <- graph_from_data_frame(edgetoadd, directed = FALSE)
g <- gtoadd %u% Gcommon
return(length(triangles(g)))
}
gc_tcounts <- c()
E <- 400
K <- 20
n_simulations <- 50
gc_tcounts <- monte_carlo(n_simulations, test1_callback,
dgc, G, Gcmissing, K, E)
# Given the test data-frame, common graph and sampled nodes, return the
# length of triangles
test1_callback <- function(dfGtest, Gcommon, missing_nodes, no_nodes, no_edges) {
sampled_nodes <- sample(missing_nodes, no_nodes)
nodestoadd <- union(sampled_nodes, V(Gcommon)$name)
edgetoadd  <- dftest[which(dfGtest$V1 %in% nodestoadd & dfGtest$V2 %in% nodestoadd), c("V1", "V2")]
edgetoadd <- edgetoadd[sample(nrow(edgetoadd), no_edges), ]
gtoadd <- graph_from_data_frame(edgetoadd, directed = FALSE)
g <- gtoadd %u% Gcommon
return(length(triangles(g)))
}
gc_tcounts <- monte_carlo(n_simulations, test1_callback,
dgc, G, Gcmissing, K, E)
# Given the test data-frame, common graph and sampled nodes, return the
# length of triangles
test1_callback <- function(dfGtest, Gcommon, missing_nodes, no_nodes, no_edges) {
sampled_nodes <- sample(missing_nodes, no_nodes)
nodestoadd <- union(sampled_nodes, V(Gcommon)$name)
edgetoadd  <- dftest[which(dfGtest$V1 %in% nodestoadd & dfGtest$V2 %in% nodestoadd), c("V1", "V2")]
edgetoadd <- edgetoadd[sample(nrow(edgetoadd), no_edges), ]
gtoadd <- graph_from_data_frame(edgetoadd, directed = FALSE)
g <- gtoadd %u% Gcommon
return(length(triangles(g)))
}
gc_tcounts <- monte_carlo(n_simulations, test1_callback,
dgc, G, Gcmissing, K, E)
# Given the test data-frame, common graph and sampled nodes, return the
# length of triangles
test1_callback <- function(dfGtest, Gcommon, missing_nodes, no_nodes, no_edges) {
sampled_nodes <- sample(missing_nodes, no_nodes)
nodestoadd <- union(sampled_nodes, V(Gcommon)$name)
edgetoadd  <- dfGtest[which(dfGtest$V1 %in% nodestoadd & dfGtest$V2 %in% nodestoadd), c("V1", "V2")]
edgetoadd <- edgetoadd[sample(nrow(edgetoadd), no_edges), ]
gtoadd <- graph_from_data_frame(edgetoadd, directed = FALSE)
g <- gtoadd %u% Gcommon
return(length(triangles(g)))
}
gc_tcounts <- monte_carlo(n_simulations, test1_callback,
dgc, G, Gcmissing, K, E)
gc_tcounts
res <- t.test(gc_tcounts, gy_tcounts)
res$p.value
E <- c(50, 100, 200, 300, 400, 500, 1000)
E <- c(50, 100, 200, 300, 400, 500, 1000)
K <- c(10, 20, 30, 40, 50, 100)
E
for(e in E) {
print(e)
}
expand.grid(E, K)
results <- expand.grid(E, K)
colname(results) <- c("Edges", "Nodes")
colnames(results) <- c("Edges", "Nodes")
results
apply(results, MARGIN=1, function(a, b) {a+b})
apply(results, MARGIN=1, function(a) {a$Edges+a$Nodes})
apply(results, MARGIN=1, function(a) {a[0]+a[1]})
apply(results, MARGIN=1, function(a) {a[1]+a[2]})
results <- expand.grid(E, K)
colnames(results) <- c("Edges", "Nodes")
results$sum <- apply(results, MARGIN=1, function(a) {a[1]+a[2]})
results
# Given the test data-frame, common graph and sampled nodes, return the
# length of triangles
sample_triangles <- function(dfGtest, Gcommon, missing_nodes, no_nodes, no_edges) {
sampled_nodes <- sample(missing_nodes, no_nodes)
nodestoadd <- union(sampled_nodes, V(Gcommon)$name)
edgetoadd  <- dfGtest[which(dfGtest$V1 %in% nodestoadd & dfGtest$V2 %in% nodestoadd), c("V1", "V2")]
edgetoadd <- edgetoadd[sample(nrow(edgetoadd), no_edges), ]
gtoadd <- graph_from_data_frame(edgetoadd, directed = FALSE)
g <- gtoadd %u% Gcommon
return(length(triangles(g)))
}
gc_tcounts <- c()
E <- c(50, 100, 200, 300, 400, 500, 1000)
K <- c(10, 20, 30, 40, 50, 100)
n_simulations <- 50
results <- expand.grid(E, K)
colnames(results) <- c("Edges", "Nodes")
results$pvalues <- apply(results, MARGIN=1, function(a) {
e <- a[1]
k <- a[2]
gc_counts <- monte_carlo(n_simulations, sample_triangles,
dgc, G, Gcmissing, k, e)
gy_counts <- monte_carlo(n_simulations, sample_triangles,
dgy, G, Gymissing, k, e)
res <- t.tests(gc_counts, gy_counts)
return(res$p.value)
})
results <- expand.grid(E, K)
colnames(results) <- c("Edges", "Nodes")
results$pvalues <- apply(results, MARGIN=1, function(a) {
e <- a[1]
k <- a[2]
gc_counts <- monte_carlo(n_simulations, sample_triangles,
dgc, G, Gcmissing, k, e)
gy_counts <- monte_carlo(n_simulations, sample_triangles,
dgy, G, Gymissing, k, e)
res <- t.test(gc_counts, gy_counts)
return(res$p.value)
})
results$pvalues <- apply(results, MARGIN=1, function(a) {
e <- a[1]
k <- a[2]
gc_counts <- monte_carlo(n_simulations, sample_triangles,
dgc, G, Gcmissing, k, e)
gy_counts <- monte_carlo(n_simulations, sample_triangles,
dgy, G, Gymissing, k, e)
res <- t.test(gc_counts, gy_counts)
return(res$p.value)
})
results
write.csv(results, "test1-results.tsv")
write.csv(results, "test1-results.tsv", sep = "\t", row.names = FALSE)
write.csv2(results, "test1-results.tsv", sep = "\t", row.names = FALSE)
write.table(results, "test1-results.tsv", sep = "\t", row.names = FALSE)
results
write.table(results, "test1-results.tsv", sep = "\t", row.names = FALSE)
compute_adj <- function(df) {
nodes <- union(df[0], df[1])
return(nodes)
}
compute_adj(dgc)
rbind(nodes, 1:length(nodes))
nodes <- union(df[0], df[1])
compute_adj <- function(df) {
nodes <- union(df[0], df[1])
rbind(nodes, 1:length(nodes))
}
compute_adj(dgc)
compute_adj <- function(df) {
nodes <- union(df[0], df[1])
cbind(nodes, 1:length(nodes))
}
compute_adj(dgc)
nodes <- union(dgc[0], dgc[1])
nodes <- union(dgc[0], dgc[1])
nodemap <- data.frame(name=nodes,
index=1:length(nodes))
nodemap
nodemap <- data.frame(symbol=nodes,
index=1:length(nodes))
nodemap
nodemap <- data.frame(nodes,
1:length(nodes))
nodemap
nodes
nodes[1]
class(nodes)
nodes <- union(dgc[0], dgc[1])
dgc[0]
dgc[0]
dgc[1]
nodes <- union(dgc[1], dgc[2])
class(nodes)
nodes
nodes[[1]]
nodes
nodemap <- data.frame(nodes[[1]],
1:length(nodes))
compute_adj(dgc)
nodes <- union(dgc[1], dgc[2])
nodemap <- data.frame(nodes[[1]],
1:length(nodes))
1:length(nodes)
1:length(nodes[[1]])
nodes <- union(dgc[[1]], dgc[[2]])
nodes
length(nodes)
nodemap <- data.frame(nodes,
1:length(nodes))
nodemap
x <- matrix(1:10, nrow=5, ncol=2)
x
x[1, 2]
x[0, 0]
x[1, 1]
rbind(nodemap, 1: length(nodes))
nodemap <- data.frame(nodes,
1:length(nodes))
nodemap
cbind(nodemap, 1: length(nodes))
cbind(nodemap, output=1: length(nodes))
m <- c(x=c(1,2,4), y=c(1,3,4))
m
m <- list(x=c(1,2,4), y=c(1,3,4))
m
data.frame(m)
p, q <- c(1, 2)
[p, q] <- c(1, 2)
g(x, y) %=% list(1, 2)
mapply(rep, 1:4, 4:1)
graph.edgelist(dgc)
graph.data.frame(dgc)
dgc
get.adjacency(Coip, sparse=FALSE, attr='V3')
Coip <- graph.data.frame(dgc)
get.adjacency(Coip, sparse=FALSE, attr='V3')
mat <- get.adjacency(Coip, sparse=FALSE, attr='V3')
length(mat)
rows(mat)
knitr::opts_chunk$set(echo = TRUE)
library("dplyr")
# install.packages("igraph")
library("igraph")
dgc <- read.csv("../data/networks/coip_hc_full.tsv", sep = "\t", header = FALSE)
dgy <- read.csv("../data/networks/y2h_hc_full.tsv", sep = "\t", header = FALSE)
dgc[which(dgc$V1 > dgc$V2), c("V1", "V2")] <- dgc[which(dgc$V1 > dgc$V2), c("V2", "V1")]
dgy[which(dgy$V1 > dgy$V2), c("V1", "V2")] <- dgy[which(dgy$V1 > dgy$V2), c("V2", "V1")]
CWN <- function(mat) {
mask <- apply(mat, 1:2 , function(x) {if (x > 0) 1 else 0})
cw <- mat %*% mask + mask %*% mat
deg <- apply(mat, 1, sum)
Deg1_2 <- diag(1 / sqrt(deg))
return(Deg1_2 %*% cw %*% Deg1_2)
}
L3 <- function(mat) {
deg <- apply(mat, 1, sum)
Deg1_2 <- diag(1 / sqrt(deg))
mat1 <- Deg1_2 %*% mat %*% Deg1_2
return(mat %*% mat1 %*% mat)
}
Coip <- graph.data.frame(dgc, directed = FALSE)
mat <- get.adjacency(Coip, sparse=FALSE, attr='V3')
apply(mat, 1:2, function(x) { if (x > 0) 1 else 0})
